<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pizza Peddler</title>
  <style>
    :root {
      --bg: #1e1f26;
      --road: #444;
      --lane: #3a3a3a;
      --grass: #6bb96b;
      --sky: #86c5e6;
      --white: #fff;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: var(--white);
      overflow: hidden;
    }
    .wrap {
      position: relative;
      width: 100vw; height: 100vh;
      display: grid; place-items: center;
    }
    canvas {
      border: 2px solid #fff;
      background: var(--sky);
      width: min(100vw, 1000px);
      height: min(75vh, 700px);
      max-height: calc(100vh - 40px);
      image-rendering: pixelated;
    }
    .hud {
      position: absolute; top: 12px; left: 12px;
      font-weight: 700; text-shadow: 0 1px 2px rgba(0,0,0,.4);
      user-select: none; pointer-events: none;
    }
    .help {
      position: absolute; bottom: 10px; left: 12px; opacity: .85;
      font-size: 13px; line-height: 1.3; user-select: none;
    }
    .toast {
      position: absolute; top: 12px; right: 12px; background: rgba(0,0,0,.5);
      padding: 6px 10px; border-radius: 8px; font-size: 13px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud" id="hud">Score: 0 | Lives: 3 | Level: 1 | Deliveries: 0</div>
    <div class="toast" id="toast"></div>
    <canvas id="c" width="900" height="600"></canvas>
    <div class="help">
      ▲/▼ change lane  •  ◀/▶ nudge speed/pos  •  Hold SPACE to aim, release to throw  •  R to restart<br/>
      Deliver to porch (green) for +150 • Yard hit +50 • Smash window −100 (ouch!)
    </div>
  </div>

  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const HUD = document.getElementById('hud');
    const TOAST = document.getElementById('toast');

    const W = canvas.width, H = canvas.height;

    // WORLD SETTINGS
    const LANES = [120, 300, 480];              // sidewalk Y centers
    const ROAD_Y1 = 60, ROAD_Y2 = H - 60;       // road band
    const GROUND_SCROLL = 3;                    // base scroll speed
    const GRAVITY = 0.35;                       // pizza gravity
    const MAX_HOLD = 900;                       // ms to max lob
    const LEVEL_UP_EVERY = 6;                   // waves per level

    // PLAYER (bike)
    const player = {
      x: 120,
      y: LANES[1] - 20,
      w: 44, h: 30,
      laneIdx: 1,
      speed: 0,      // horizontal nudge
      invuln: 0,     // frames after hit
      aimHold: 0,    // ms held space
      aiming: false
    };

    let keys = {};
    onkeydown = e => { keys[e.code] = true; };
    onkeyup   = e => { keys[e.code] = false; if (e.code === 'Space') releaseThrow(); };

    // ENTITIES
    const pizzas = [];
    const houses = [];   // each has y lane, door rect, window rects, porch rect
    const obstacles = []; // cars/dogs/potholes on road band

    // GAME STATE
    let score = 0, lives = 3, deliveries = 0, level = 1, wave = 0;
    let gameOver = false, flashFrames = 0, scroll = 0;
    let lastTime = 0;

    function rand(min, max){ return Math.random()*(max-min)+min; }
    function irand(min, max){ return Math.floor(rand(min,max)); }

    function showToast(msg, ms=1200){
      TOAST.textContent = msg;
      TOAST.style.opacity = '1';
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=> TOAST.style.opacity = '0', ms);
    }

    // ---- SPAWNERS ----
    function spawnWave() {
      wave++;
      // How many houses this wave?
      const count = 3 + Math.min(3, level-1); // 3..6
      const lanes = [0,1,2].sort(()=>Math.random()-0.5);
      for(let i=0;i<count;i++){
        const lane = lanes[i % lanes.length];
        const baseX = W + 200 + i * irand(250, 340);
        houses.push(makeHouse(baseX, lane));
      }
      // Obstacles on road
      const obsCount = 2 + Math.min(3, level);
      for(let i=0;i<obsCount;i++){
        obstacles.push(makeObstacle(W + 200 + i * irand(220, 360)));
      }

      if (wave % LEVEL_UP_EVERY === 0) {
        level++;
        showToast(`Level Up! Level ${level}`);
      }
    }

    function makeHouse(x, laneIdx){
      const yCenter = LANES[laneIdx];
      // House body
      const w = 80, h = 70;
      const y = yCenter - h/2 - 20; // sit above sidewalk
      // Porch target
      const porch = { x: x+10, y: y+h-12, w: 45, h: 12 };
      // Door (within porch)
      const door  = { x: x+18, y: y+h-40, w: 18, h: 28 };
      // One front window to "break"
      const window = { x: x+50, y: y+18, w: 18, h: 14, broken:false };
      return { x, y, w, h, laneIdx, porch, door, window, delivered:false, scored:false };
    }

    function makeObstacle(x){
      // Random type & lane on road band
      const types = ['car','dog','pothole'];
      const type = types[irand(0, types.length)];
      const y = irand(ROAD_Y1+60, ROAD_Y2-60);
      const speed = GROUND_SCROLL + rand(1.5, 3.5) + (level*0.2);
      // hitbox sizes
      const size = type==='car' ? {w:70,h:34} : type==='dog' ? {w:44,h:26} : {w:30,h:14};
      return { type, x, y, ...size, speed };
    }

    // ---- THROWING ----
    function releaseThrow(){
      if (gameOver) return;
      if (!player.aiming) return;
      // Convert aimHold (0..MAX_HOLD) to angle and power
      const t = Math.min(player.aimHold, MAX_HOLD) / MAX_HOLD; // 0..1
      const angle = 0.35 + t * 0.9; // radians upward; ~20°..73°
      const speed = 9 + t * 6;      // base velocity
      const dir = keys['ArrowLeft'] ? -1 : 1; // you can lob backwards
      pizzas.push({
        x: player.x + player.w, 
        y: player.y,
        w: 16, h: 10,
        vx: Math.cos(angle) * speed * dir + player.speed*0.4,
        vy: -Math.sin(angle) * speed
      });
      player.aiming = false;
      player.aimHold = 0;
    }

    // ---- UPDATE ----
    function update(dt){
      if (gameOver) return;

      // Start aiming / charge throw
      if (keys['Space']) {
        player.aiming = true;
        player.aimHold += dt;
      }

      // Lane changes
      if (keys['ArrowUp'] && player.laneIdx > 0) { player.laneIdx--; keys['ArrowUp']=false; }
      if (keys['ArrowDown'] && player.laneIdx < 2) { player.laneIdx++; keys['ArrowDown']=false; }
      player.y = LANES[player.laneIdx] - 20;

      // Horizontal nudge (feels better than fixed x)
      if (keys['ArrowLeft'])  player.x = Math.max(40, player.x - 4);
      if (keys['ArrowRight']) player.x = Math.min(W*0.6, player.x + 4);

      // Basic parallax scroll increases with level
      const scrollSpeed = GROUND_SCROLL + (level-1)*0.6;
      scroll += scrollSpeed;

      // Move entities left
      for (const h of houses) h.x -= scrollSpeed;
      for (const o of obstacles) o.x -= o.speed;

      // Pizzas physics
      for (let i = pizzas.length-1; i>=0; i--){
        const p = pizzas[i];
        p.vy += GRAVITY;
        p.x  += p.vx;
        p.y  += p.vy;

        // Hit ground? stick and fade
        if (p.y > H - 50){
          pizzas.splice(i,1);
          continue;
        }

        // Collide with houses
        for (const house of houses){
          if (rectHit(p, house)){ // hit the facade (yard)
            score += 50;
            pizzas.splice(i,1);
            break;
          }
          if (rectHit(p, house.porch)){ // porch/doorstep
            if (!house.delivered){
              deliveries++;
              score += 150;
              house.delivered = true;
              house.scored = true;
            }
            pizzas.splice(i,1);
            break;
          }
          if (!house.window.broken && rectHit(p, house.window)){ // window break
            house.window.broken = true;
            score = Math.max(0, score - 100);
            flashFrames = 8;
            pizzas.splice(i,1);
            break;
          }
        }
      }

      // Remove off-screen entities & spawn new wave if needed
      prune(houses, h => h.x + h.w < -50);
      prune(obstacles, o => o.x + o.w < -50);
      if (houses.length < 2) spawnWave();

      // Collisions with road obstacles (only if roughly road band)
      if (player.invuln > 0) player.invuln -= 1;
      for (const o of obstacles){
        if (rectsOverlap(player, o) && player.invuln <= 0){
          lives--;
          player.invuln = 45; // ~¾ sec at 60fps
          flashFrames = 10;
          if (lives <= 0) gameOver = true;
          break;
        }
      }

      HUD.textContent = `Score: ${score} | Lives: ${lives} | Level: ${level} | Deliveries: ${deliveries}`;
    }

    function prune(arr, pred){
      for (let i=arr.length-1;i>=0;i--) if (pred(arr[i])) arr.splice(i,1);
    }

    function rectHit(a, b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }
    function rectsOverlap(a, b){ return rectHit(a,b); }

    // ---- DRAW ----
    function draw(){
      // sky
      ctx.fillStyle = '#86c5e6';
      ctx.fillRect(0,0,W,H);

      // far background (simple parallax hills)
      ctx.fillStyle = '#9cd1ec';
      for (let i=0;i<6;i++){
        const base = (scroll*0.2 + i*300) % (W+300) - 300;
        ctx.beginPath();
        ctx.ellipse(W - base, H-150, 160, 60, 0, 0, Math.PI*2);
        ctx.fill();
      }

      // grass strips
      ctx.fillStyle = '#6bb96b';
      ctx.fillRect(0, 0, W, 60);
      ctx.fillRect(0, H-60, W, 60);

      // road
      ctx.fillStyle = '#444';
      ctx.fillRect(0, ROAD_Y1, W, ROAD_Y2-ROAD_Y1);

      // sidewalks (lane guides)
      ctx.strokeStyle = '#5a5a5a';
      ctx.setLineDash([10,12]);
      ctx.lineWidth = 2;
      LANES.forEach(y=>{
        ctx.beginPath();
        ctx.moveTo(0, y+20);
        ctx.lineTo(W, y+20);
        ctx.stroke();
      });
      ctx.setLineDash([]);

      // houses
      for (const h of houses){
        // house body
        ctx.fillStyle = '#6a89cc';
        ctx.fillRect(h.x, h.y, h.w, h.h);
        // roof
        ctx.fillStyle = '#3d3d3d';
        ctx.beginPath();
        ctx.moveTo(h.x-6, h.y);
        ctx.lineTo(h.x + h.w/2, h.y - 18);
        ctx.lineTo(h.x + h.w+6, h.y);
        ctx.closePath(); ctx.fill();

        // porch (target)
        ctx.fillStyle = h.delivered ? '#2ecc71' : '#2d8b57';
        ctx.fillRect(h.porch.x, h.porch.y, h.porch.w, h.porch.h);

        // door
        ctx.fillStyle = '#c6d8f0';
        ctx.fillRect(h.door.x, h.door.y, h.door.w, h.door.h);

        // window (breakable)
        ctx.fillStyle = h.window.broken ? '#b23b3b' : '#a8e4ff';
        ctx.fillRect(h.window.x, h.window.y, h.window.w, h.window.h);
      }

      // obstacles
      for (const o of obstacles){
        if (o.type === 'car'){
          ctx.fillStyle = '#e74c3c';
          ctx.fillRect(o.x, o.y, o.w, o.h);
          ctx.fillStyle = '#111';
          ctx.fillRect(o.x+6, o.y+o.h-6, 12, 6);
          ctx.fillRect(o.x+o.w-18, o.y+o.h-6, 12, 6);
        } else if (o.type === 'dog'){
          ctx.fillStyle = '#8e5a2b';
          ctx.fillRect(o.x, o.y, o.w, o.h);
          ctx.fillStyle = '#000';
          ctx.fillRect(o.x+o.w-6, o.y+4, 6, 6);
        } else {
          // pothole
          ctx.fillStyle = '#2a2a2a';
          ctx.beginPath();
          ctx.ellipse(o.x+o.w/2, o.y+o.h/2, o.w/2, o.h/2, 0, 0, Math.PI*2);
          ctx.fill();
        }
      }

      // pizzas
      for (const p of pizzas){
        ctx.fillStyle = '#c07c3a';
        ctx.fillRect(p.x, p.y, p.w, p.h);
        ctx.fillStyle = '#f5d27a';
        ctx.fillRect(p.x+2, p.y+2, p.w-4, p.h-4);
      }

      // player bike (simple)
      const flicker = (player.invuln>0 && Math.floor(player.invuln/3)%2===0);
      if (!flicker){
        ctx.fillStyle = '#ff355e';
        ctx.fillRect(player.x, player.y, player.w, player.h);
        // wheels
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.arc(player.x+8, player.y+player.h, 8, 0, Math.PI*2); ctx.fill();
        ctx.beginPath();
        ctx.arc(player.x+player.w-8, player.y+player.h, 8, 0, Math.PI*2); ctx.fill();
      }

      // aim guide
      if (player.aiming){
        const t = Math.min(player.aimHold, MAX_HOLD)/MAX_HOLD;
        const angle = 0.35 + t*0.9;
        const len = 60 + t*40;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(player.x + player.w, player.y+5);
        ctx.lineTo(player.x + player.w + Math.cos(angle)*len, player.y+5 - Math.sin(angle)*len);
        ctx.stroke();
      }

      // hit flash
      if (flashFrames > 0){
        flashFrames--;
        ctx.fillStyle = 'rgba(255,255,255,.25)';
        ctx.fillRect(0,0,W,H);
      }

      if (gameOver){
        ctx.fillStyle = 'rgba(0,0,0,.6)';
        ctx.fillRect(0,0,W,H);
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.font = 'bold 40px Arial';
        ctx.fillText('Game Over', W/2, H/2 - 20);
        ctx.font = '24px Arial';
        ctx.fillText(`Final Score: ${score}   Deliveries: ${deliveries}   Level: ${level}`, W/2, H/2 + 20);
        ctx.fillText('Press R to Restart', W/2, H/2 + 60);
      }
    }

    // ---- LOOP ----
    function loop(ts){
      const dt = Math.min(40, ts - (lastTime||ts)); // clamp dt
      lastTime = ts;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    function reset(){
      score=0; lives=3; deliveries=0; level=1; wave=0; gameOver=false;
      player.x=120; player.laneIdx=1; player.y=LANES[1]-20; player.invuln=0; player.aimHold=0; player.aiming=false;
      houses.length=0; obstacles.length=0; pizzas.length=0; scroll=0; flashFrames=0;
      spawnWave();
      showToast('Deliver pizzas! Hold SPACE to aim, release to throw.');
    }

    addEventListener('keydown', (e)=>{
      if (e.code==='KeyR' && gameOver) reset();
    });

    // boot
    reset();
    requestAnimationFrame(loop);
  </script>
</body>
</html>