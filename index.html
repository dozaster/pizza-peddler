<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Pizza Peddler — Kong Delivery</title>
<style>
  :root{
    --sky:#86c5e6; --ink:#111; --white:#fff;
    --platform:#3f3f46; --ladder:#d6e4ff; --goal:#2ecc71; --goal2:#2d8b57;
    --player:#ff355e; --barrel:#c07c3a; --barrel2:#f5d27a;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:#1f2026;color:var(--white);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}
  .wrap{position:relative;width:100vw;height:100vh;display:grid;place-items:center}
  canvas{
    border:2px solid var(--white);
    background:var(--sky);
    width:min(100vw,1100px);height:min(78vh,800px);max-height:calc(100vh - 40px);
    image-rendering:pixelated
  }
  .hud{position:absolute;top:10px;left:12px;font-weight:700;text-shadow:0 1px 2px rgba(0,0,0,.35);user-select:none;pointer-events:none}
  .help{position:absolute;bottom:10px;left:12px;opacity:.9;font-size:13px;line-height:1.3;user-select:none}
  .toast{position:absolute;top:10px;right:12px;background:rgba(0,0,0,.5);padding:6px 10px;border-radius:8px;font-size:13px}
</style>
</head>
<body>
  <div class="wrap">
    <div class="hud" id="hud">Score: 0 | Lives: 3 | Round: 1</div>
    <div class="toast" id="toast"></div>
    <canvas id="c" width="1000" height="650"></canvas>
    <div class="help">
      ◀/▶ move • ▲/▼ climb ladder • SPACE jump • SPACE on the green zone to deliver • R to restart<br/>
      Tip: Barrels are slow and sparse. Take your time, watch edges, use ladders as safe spots.
    </div>
  </div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const HUD = document.getElementById('hud');
const TOAST = document.getElementById('toast');
const W = canvas.width, H = canvas.height;

// ---------- GAME STATE ----------
let score=0, lives=3, roundN=1, last=0, gameOver=false, flash=0;

// Platforms (top to bottom)
const PLAT_COUNT = 5;
const PLAT_GAP   = 110;         // vertical spacing
const PLAT_THICK = 14;
const TOP_Y      = 90;
const platforms = [];           // {x1,x2,y,dir} dir: 1 right, -1 left (for barrels)

// Ladders (x,y1,y2)
const ladders = [];

// Goal zone at the top left
const goal = { x: 70, y: TOP_Y-48, w: 120, h: 28 };

// Player
const player = {
  x: 120, y: H-80,
  w: 26, h: 30,
  vx: 0, vy: 0,
  onGround: false,
  onLadder: false,
  climbSpeed: 2.2,
  moveSpeed: 2.4,
  jumpVel: -7.6,
  inv: 0
};

// Barrels
const barrels = []; // {x,y,w,h,vx,vy,platIndex,grounded}
let barrelMs=0, barrelDelay=2400; // easier cadence
let maxBarrels=3;                 // cap

// Input
const keys={};
onkeydown = e => { keys[e.code]=true; };
onkeyup   = e => { keys[e.code]=false; if(e.code==='Space') tryDeliver(); };
addEventListener('keydown', e => { if(e.code==='KeyR' && gameOver) reset(); });

function toast(msg, ms=1200){ TOAST.textContent=msg; TOAST.style.opacity='1'; clearTimeout(toast._t); toast._t=setTimeout(()=>TOAST.style.opacity='0',ms); }
const clamp=(n,mi,ma)=>Math.max(mi,Math.min(ma,n));

// ---------- WORLD BUILD ----------
function buildWorld(){
  platforms.length=0; ladders.length=0;

  // Stagger platforms alternating directions (barrel roll direction)
  for (let i=0;i<PLAT_COUNT;i++){
    const y = TOP_Y + i*PLAT_GAP;
    const dir = (i%2===0) ? -1 : 1; // top goes left, next goes right, etc.
    const margin = 70;
    const x1 = margin + (i%2===0 ? 40 : 0);
    const x2 = W - margin - (i%2===1 ? 40 : 0);
    platforms.push({ x1, x2, y, dir });
  }

  // Ladders between platforms (multiple per level, generous alignment)
  for (let i=0;i<PLAT_COUNT-1;i++){
    const y1 = platforms[i].y + PLAT_THICK;
    const y2 = platforms[i+1].y - 2;
    const xs = [
      platforms[i].x1 + 80,
      (platforms[i].x1 + platforms[i].x2)/2,
      platforms[i].x2 - 80
    ];
    xs.forEach(x => ladders.push({ x: Math.floor(x), y1, y2 }));
  }
}

// ---------- PLAYER LOGIC ----------
function updatePlayer(){
  // Ladder check (snap when centered on ladder)
  player.onLadder = false;
  for (const L of ladders){
    const nearX = Math.abs((player.x + player.w/2) - L.x) < 14;
    const withinY = (player.y + player.h/2) > L.y1 && (player.y + player.h/2) < L.y2;
    if (nearX && withinY){
      if (keys['ArrowUp'] || keys['ArrowDown']){
        player.onLadder = true;
        // lock x to ladder center
        player.x = L.x - player.w/2;
        break;
      }
    }
  }

  // Horizontal
  let move = 0;
  if (keys['ArrowLeft'])  move -= 1;
  if (keys['ArrowRight']) move += 1;
  player.vx = move * player.moveSpeed;

  // Vertical
  const GRAV = 0.38;
  if (player.onLadder){
    // climbing overrides gravity
    if (keys['ArrowUp'])   player.vy = -player.climbSpeed;
    else if (keys['ArrowDown']) player.vy =  player.climbSpeed;
    else player.vy = 0;
    player.onGround = false;
  } else {
    // jumping
    if (keys['Space'] && player.onGround){
      player.vy = player.jumpVel;
      player.onGround = false;
    }
    player.vy += GRAV;
  }

  // Integrate
  player.x += player.vx;
  player.y += player.vy;

  // World bounds
  player.x = clamp(player.x, 0, W - player.w);
  if (player.y > H - 40 - player.h){
    player.y = H - 40 - player.h; player.vy = 0; player.onGround = true;
  }

  // Platform collisions (feet landing)
  if (!player.onLadder){
    player.onGround = false;
    const pxCenter = player.x + player.w/2;
    for (const p of platforms){
      const isWithinX = pxCenter > p.x1 && pxCenter < p.x2;
      const isFalling = player.vy >= 0;
      const foot = player.y + player.h;
      if (isWithinX && isFalling && foot >= p.y && foot <= p.y + PLAT_THICK + 6){
        player.y = p.y - player.h;
        player.vy = 0;
        player.onGround = true;
      }
    }
  }

  if (player.inv>0) player.inv--;
}

// ---------- BARRELS ----------
function spawnBarrel(){
  if (barrels.length >= maxBarrels) return;
  // spawn near top-right by the “apartment”
  const pTop = platforms[0];
  const startX = pTop.x2 - 30;
  const startY = pTop.y - 18;
  const dir = pTop.dir; // -1 goes left
  const speed = 1.6 + (roundN-1)*0.15; // gently ramps
  barrels.push({
    x: startX, y: startY, w:22, h:18,
    vx: dir * speed,
    vy: 0,
    platIndex: 0,
    grounded: true
  });
}

function updateBarrels(){
  const GRAV = 0.40;
  for (let i=barrels.length-1;i>=0;i--){
    const b = barrels[i];

    // Horizontal roll if grounded
    if (b.grounded) b.x += b.vx;
    else {
      b.vy += GRAV;
      b.y  += b.vy;
    }

    // At platform edge? drop to next platform
    const p = platforms[b.platIndex];
    if (b.grounded && (b.x < p.x1 - 6 || b.x + b.w > p.x2 + 6)){
      b.grounded = false;
      b.vy = 0.5;
    }

    // Land on next platform
    if (!b.grounded){
      const nextIdx = Math.min(PLAT_COUNT-1, b.platIndex + 1);
      const np = platforms[nextIdx];
      const mid = b.x + b.w/2;
      if (b.y + b.h >= np.y && mid > np.x1 && mid < np.x2){
        b.y = np.y - b.h;
        b.platIndex = nextIdx;
        b.grounded = true;
        // new horizontal direction based on that platform
        b.vx = platforms[nextIdx].dir * (Math.abs(b.vx));
      }
      // fell below world — remove
      if (b.y > H) { barrels.splice(i,1); continue; }
    }

    // Remove if way off screen horizontally
    if (b.x < -80 || b.x > W+80){ barrels.splice(i,1); continue; }

    // Collision with player
    const hit = rectHit(b, player);
    if (hit) damage();
  }
}

// ---------- GOAL / SCORING ----------
function tryDeliver(){
  if (gameOver) return;
  // Press SPACE while overlapping goal area (top)
  const pRect = { x: player.x, y: player.y, w: player.w, h: player.h };
  if (rectHit(pRect, goal)){
    score += 500 + (roundN*50);
    roundN++;
    // Gentle difficulty bump
    barrelDelay = Math.max(1500, barrelDelay - 100);
    maxBarrels  = Math.min(6, maxBarrels + (roundN%2===0 ? 1 : 0));
    // Reset player and clear some barrels (keep it friendly)
    while (barrels.length > 2) barrels.pop();
    placePlayerAtStart();
    toast('Delivered! New round.');
  }
}

function placePlayerAtStart(){
  player.x = 120; player.y = H-80; player.vx=0; player.vy=0; player.onGround=false; player.inv=30;
}

function damage(){
  if (player.inv>0 || gameOver) return;
  lives--; flash=10;
  placePlayerAtStart();
  if (lives<=0) gameOver = true;
}

function rectHit(a,b){
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

// ---------- LOOP ----------
function update(dt){
  if (gameOver) return;

  // Spawns
  barrelMs += dt;
  if (barrelMs > barrelDelay){ barrelMs = 0; spawnBarrel(); }

  updatePlayer();
  updateBarrels();

  HUD.textContent = `Score: ${score} | Lives: ${lives} | Round: ${roundN}`;
}

function draw(){
  // sky
  ctx.fillStyle = '#bfe7fb'; ctx.fillRect(0,0,W,H);

  drawPlatforms();
  drawLadders();
  drawGoal();

  // barrels
  for (const b of barrels){
    ctx.fillStyle = 'var(--barrel)';
    ctx.fillStyle = '#c07c3a'; ctx.fillRect(b.x,b.y,b.w,b.h);
    ctx.fillStyle = '#f5d27a'; ctx.fillRect(b.x+3,b.y+3,b.w-6,b.h-6);
  }

  // player
  const blink = (player.inv>0 && Math.floor(player.inv/3)%2===0);
  if (!blink){
    ctx.fillStyle = '#ff355e';
    ctx.fillRect(player.x, player.y, player.w, player.h);
    // little feet
    ctx.fillStyle = '#111';
    ctx.fillRect(player.x+4, player.y+player.h-3, 7,3);
    ctx.fillRect(player.x+player.w-11, player.y+player.h-3, 7,3);
  }

  // ground label
  ctx.fillStyle = '#6e6e78'; ctx.fillRect(0,H-40,W,40);
  ctx.fillStyle = 'rgba(0,0,0,.2)'; ctx.fillRect(0,H-40, W, 4);
  ctx.fillStyle = 'rgba(255,255,255,.7)'; ctx.font='12px Arial';
  ctx.fillText('Pizzeria — Start', 24, H-18);

  if (flash>0){ flash--; ctx.fillStyle='rgba(255,255,255,.25)'; ctx.fillRect(0,0,W,H); }

  if (gameOver){
    ctx.fillStyle='rgba(0,0,0,.65)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#fff'; ctx.textAlign='center';
    ctx.font='bold 42px Arial'; ctx.fillText('Game Over', W/2, H/2 - 28);
    ctx.font='22px Arial'; ctx.fillText(`Score: ${score} • Round: ${roundN}`, W/2, H/2 + 8);
    ctx.fillText('Press R to Restart', W/2, H/2 + 40);
    ctx.textAlign='left';
  }
}

function drawPlatforms(){
  ctx.fillStyle = '#3f3f46';
  for (const p of platforms){
    ctx.fillRect(p.x1, p.y, p.x2 - p.x1, PLAT_THICK);
    // rail
    ctx.fillStyle = '#2e333a';
    ctx.fillRect(p.x1, p.y-6, p.x2 - p.x1, 4);
    ctx.fillStyle = '#3f3f46';
  }
}

function drawLadders(){
  ctx.strokeStyle = '#d6e4ff'; ctx.lineWidth = 3;
  ladders.forEach(L=>{
    // rails
    ctx.beginPath(); ctx.moveTo(L.x-6, L.y1); ctx.lineTo(L.x-6, L.y2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(L.x+6, L.y1); ctx.lineTo(L.x+6, L.y2); ctx.stroke();
    // rungs
    ctx.lineWidth = 2;
    for (let y=L.y1+8; y<L.y2-2; y+=12){
      ctx.beginPath(); ctx.moveTo(L.x-6, y); ctx.lineTo(L.x+6, y); ctx.stroke();
    }
    ctx.lineWidth = 3;
  });
}

function drawGoal(){
  // Little apartment box + glowing deliver zone
  ctx.fillStyle = '#6a89cc';
  ctx.fillRect(goal.x-20, goal.y-42, goal.w+40, 36);
  ctx.fillStyle = '#2b2b30';
  ctx.fillRect(goal.x-22, goal.y-46, goal.w+44, 6);

  ctx.fillStyle = '#2ecc71';
  ctx.fillRect(goal.x, goal.y, goal.w, goal.h);
  ctx.strokeStyle='rgba(46,204,113,.85)'; ctx.lineWidth=3;
  ctx.strokeRect(goal.x-2, goal.y-2, goal.w+4, goal.h+4);

  ctx.fillStyle='#111'; ctx.fillRect(goal.x+10, goal.y-24, 26, 18); // door
  ctx.fillStyle='#aee6ff'; ctx.fillRect(goal.x+50, goal.y-30, 18, 14); // window
  ctx.fillStyle='#fff'; ctx.font='bold 12px Arial'; ctx.textAlign='center';
  ctx.fillText('DELIVER', goal.x + goal.w/2, goal.y + goal.h/2 + 4);
  ctx.textAlign='left';
}

// ---------- MAIN ----------
function loop(ts){
  const dt = Math.min(40, ts - (last||ts)); last = ts;
  update(dt); draw(); requestAnimationFrame(loop);
}

function reset(){
  score=0; lives=3; roundN=1; gameOver=false; flash=0;
  barrelMs=0; barrelDelay=2400; maxBarrels=3;
  barrels.length=0;
  buildWorld();
  placePlayerAtStart();
  toast('Climb up and press SPACE on the green zone to deliver!');
}

reset();
requestAnimationFrame(loop);
</script>
</body>
</html>